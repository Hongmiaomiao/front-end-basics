# 前端模块化

TODO: 理解静态引入、动态引入
// 引入模块时候的执行、变量后续的变化

<!-- [1. amd\cmd的区别](https://juejin.cn/post/6844903541853650951) -->

## 为什么要有模块化

1. 可维护性
因为模块是独立的，一个设计良好的模块会让外面的代码对自己的依赖越少越好，这样自己就可以独立去更新和改进。
2. 命令空间
在 JavaScript 里面，如果一个变量在最顶级的函数之外声明，它就直接变成全局可用。因此，常常不小心出现命名冲突的情况。使用模块化开发来封装变量，可以避免污染全局环境。
3. 复用代码
以往我们可能通过拷贝代码来实现复用，通过模块引用的方式，来避免重复的代码库。我们可以在更新了模块之后，让引用了该模块的所有项目都同步更新，还能指定版本号，避免 API 变更带来的麻烦。

## 模块化发展阶段

命名空间 => commonjs => amd、cmd => es6模块

### commonjs

同步加载 => 只有加载完成，才能继续执行后续的操作  

#### 优缺点

commonjs同步加载的特性使得它在服务端使用、浏览器不适用，原因：

1. 服务端加载文件一般可以从本地读取。
2. 浏览器端要走网络请求，会比较耗时。并且同步的特性使得它将阻塞页面渲染。

#### 写法

通过require引入模块，module.exports导出模块

### amd （Asynchronous Module Definition）

异步模块定义，所谓异步是指模块和模块的依赖可以被异步加载，他们的加载不会影响它后面语句的运行。有效避免了采用同步加载方式中导致的页面假死现象。AMD代表：RequireJS。

#### amd优缺点

AMD 运行时核心思想是「Early Executing」，也就是提前执行依赖 AMD 的这个特性有好有坏：
首先，尽早执行依赖可以尽早发现错误。
另外，尽早执行依赖通常可以带来更好的用户体验，也容易产生浪费。
目前，主要有两个Javascript库实现了AMD规范：require.js和curl.js
在浏览器环境中异步加载模块；并行加载多个模块；
开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅；不符合通用的模块化思维方式，是一种妥协的实现。

#### amd写法

通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载。

### cmd(Common Module Definition)

CMD是SeaJS在推广过程中生产的对模块定义的规范，在Web浏览器端的模块加载器中，SeaJS与RequireJS并称，SeaJS作者为阿里的玉伯。
CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。

#### CMD的优缺点

优点：依赖就近，延迟执行 可以很容易在 Node.js 中运行；
缺点：依赖 SPM 打包，模块的加载逻辑偏重；

## es6 模块

ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。所以说ES6是编译时加载，不同于CommonJS的运行时加载(实际加载的是一整个对象)，ES6模块不是对象，而是通过export命令显式指定输出的代码，输入时也采用静态命令的形式。

### es6模块与commjs的差别

1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。